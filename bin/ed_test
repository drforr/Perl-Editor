#!/usr/bin/perl

use warnings;
use strict;
use Carp qw(croak);
use Readonly;

use FindBin qw($Bin);
use lib qq{$Bin/../lib};
use Curses;
use POE;
use POE::Wheel::Curses;

use Pane;
use Pane::Edit;

#
# Available modes:
#
# Normal
# Visual
# Insert
# Command-line
#
my %editor_key;
my %inline_state;

#
# Attributes were kinda neat, but cluttering up the namespace.
#
# {{{ Normal({ trie => $trie, sub => $sub })
sub Normal
  {
  my ( $args ) = @_;
  my $trie     = $args->{trie};

  $trie = [ $trie ] unless ref $trie;

  for my $key ( @$trie )
    {
    $editor_key{normal}{$key} = $args->{sub};
    }
  }

# }}}

# {{{ Insert({ trie => $trie, sub => $sub })
sub Insert
  {
  my ( $args ) = @_;
  my $trie     = $args->{trie};

  $trie = [ $trie ] unless ref $trie;

  for my $key ( @$trie )
    {
    $editor_key{insert}{$key} = $args->{sub};
    }
  }

# }}}

# {{{ State({ name => $name, sub => $sub })
sub State
  {
  my ( $args ) = @_;
  my $name     = $args->{name};
  my $sub      = $args->{sub};

  $inline_state{$name} = sub
    {
    $sub->
      ({
      kernel => $_[KERNEL],
      heap   => $_[HEAP],
      args   => [ @_[ ARG0 .. $#_ ] ],
      });
    };
  }

# }}}

# {{{ Normal keystrokes

# {{{ Normal '\cL'
Normal
  ({
  trie => qq{\cL},
  sub => sub
    {
    my ( $args ) = @_;
    my $kernel   = $args->{kernel};
 
    $kernel->yield(q{update});
    }
  });

# }}}

# {{{ Normal 'q'
Normal
  ({
  trie => 'q',
  sub => sub
    {
    my ( $args ) = @_;
    my $kernel   = $args->{kernel};

    $kernel->yield(q{quit});
    }
  });

# }}}

# {{{ Normal 'u'
Normal
  ({
  trie => 'u',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->undo;
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'x'
Normal
  ({
  trie => 'x',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};

    $pane->delete;
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_BACKSPACE
Normal
  ({
  trie => 'KEY_BACKSPACE',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};

    $pane->cursor_left;
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_END, 'G'
Normal
  ({
  trie => ['KEY_END', 'G'],
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->cursor_flush_bottom();
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_DOWN, 'j'
Normal
  ({
  trie => ['KEY_DOWN', 'j'],
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->cursor_down();
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_UP, 'k'
Normal
  ({
  trie => ['KEY_UP', 'k'],
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->cursor_up();
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_HOME
Normal
  ({
  trie => 'KEY_HOME',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->cursor_flush_top();
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_EOL, '$'
Normal
  ({
  trie => ['KEY_EOL','$'],
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->cursor_flush_right();
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_RIGHT, 'l', ' '
Normal
  ({
  trie => ['KEY_RIGHT','l',' '],
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->cursor_right();
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_LEFT, 'h'
Normal
  ({
  trie => ['KEY_LEFT','h'],
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};

    $pane->cursor_left();
    $pane->update;
    }
  });

# }}}

# {{{ Normal KEY_BEG, '0'
Normal
  ({
  trie => ['KEY_BEG','0'],
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->cursor_flush_left();
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'i'
Normal
  ({
  trie => 'i',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->set_mode({ mode => q{insert} });
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'I'
Normal
  ({
  trie => 'I',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->set_mode({ mode => q{insert} });
    $pane->cursor_flush_left;
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'a'
Normal
  ({
  trie => 'a',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->set_mode({ mode => q{insert} });
    $pane->cursor_right;
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'A'
Normal
  ({
  trie => 'A',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->set_mode({ mode => q{insert} });
    $pane->cursor_flush_right;
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'o'
Normal
  ({
  trie => 'o',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->set_mode({ mode => q{insert} });
    $pane->insert_line;
    $pane->cursor_down;
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'O'
Normal
  ({
  trie => 'O',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
    
    $pane->set_mode({ mode => q{insert} });
    $pane->insert_line;
    $pane->update;
    }
  });

# }}}


# {{{ Normal 'H'
Normal
  ({
  trie => 'H',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->viewport_left();
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'J'
Normal
  ({
  trie => 'J',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->viewport_down();
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'K'
Normal
  ({
  trie => 'K',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->viewport_up();
    $pane->update;
    }
  });

# }}}

# {{{ Normal 'L'
Normal
  ({
  trie => 'L',
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->viewport_right();
    $pane->update;
    }
  });

# }}}

# }}}

# {{{ Insert keystrokes

# {{{ Insert KEY_BACKSPACE
Insert
  ({
  trie => q{KEY_BACKSPACE},
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->cursor_left;
    $pane->delete;
    $pane->update;
    }
  });

# }}}

# {{{ Insert '\e'
Insert
  ({
  trie => "\e",
  sub => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->set_mode({ mode => q{normal} });
    $pane->update;
    }
  });

# }}}

# {{{ Insert [...]
Insert
  ({
  trie =>
    [
    'a'..'z',
    'A'..'Z',
    '0'..'9',
    ' ',
    '#',
    ',',
    qw( ( [ { ` ~ ! @ $ % ^ & * - _ = + | ; : ' " < . > \ / ? } ] ) )
    ],
  sub => sub
    {
    my ( $args, $keystroke ) = @_;
    my $pane                 = $args->{heap}->{pane};
 
    $pane->insert({ keystroke => $keystroke });
    $pane->cursor_right;
    $pane->update;
    }
  });

# }}}

# }}}

# {{{ get_lines({ filename => $filename })
sub get_lines
  {
  my ( $args ) = @_;
  my $filename = $args->{filename};
  my $lines    = [];

  croak qq{Could not find file '$filename'.} unless -e $filename;
  croak qq{'$filename' is not a file.} unless -f $filename;
  
  open my $fh, $filename or die qq{Could not open '$filename'};
  @$lines = map { chomp; $_ } <$fh>;
  close $fh;
  return $lines;
  }

# }}}

# {{{ Event handlers

# {{{ console_initialize
#
# Initialize the console interface.
#
State
  ({
  name => '_start',
  sub  => sub 
    {
    my ( $args ) = @_;
    my $kernel   = $args->{kernel};
    my $heap     = $args->{heap};
    my $filename = $args->{args}[0];

    $heap->{curses} = POE::Wheel::Curses->new( InputEvent => q{got_input} );

# {{{ Collect the longest string
    my $file       = get_lines({ filename => $filename });
    my $pane_width = length($file->[0]);
    for my $line_len ( map { length($_) } @$file )
      {
      $pane_width = $line_len if $line_len > $pane_width;
      }

# }}}

# {{{ Create scrolling pane
    $heap->{pane} = Pane::Edit->new
      ({
      pane_height     => scalar(@$file),
      viewport_height => $Curses::LINES - 1,
      pane_width      => $pane_width,
      viewport_width  => $Curses::COLS,
      content         => $file,
      });

# }}}

    $kernel->yield(q{update});
    }
  });

# }}}

# {{{ curses_refresh
#
# Refresh the entire screen
#
State
  ({
  name => 'update',
  sub  => sub
    {
    my ( $args ) = @_;
    my $pane     = $args->{heap}->{pane};
 
    $pane->update;
    }
  });

# }}}

# {{{ console_quit
#
# Print the closing text
# Destroy the heap items we allocated
#
State
  ({
  name => 'quit',
  sub  => sub
    {
    my ( $args ) = @_;
    my $kernel   = $args->{kernel};
    my $heap     = $args->{heap};
    my $row      = $Curses::LINES - 2;
 
    move( $row++, 0 ); clrtoeol(); addstr(qq{Editor has quit.});
    move( $row++, 0 ); clrtoeol();
    noutrefresh();
    doupdate;
 
    $kernel->alias_remove(q{console});
    $kernel->alarm_remove_all();
    delete $heap->{curses};
    }
  });

# }}}

# {{{ curses_input
#
# Perform editor actions for keystrokes
#
State
  ({
  name => 'got_input',
  sub  => sub
    {
    my ( $args )  = @_;
    my $keystroke = $args->{args}[0];
    my $mode      = $args->{heap}{pane}{mode};

    $keystroke = uc( keyname($keystroke) ) if
      $keystroke =~ m{ ^ \d{2,} $ }x;

    for my $ed_mode ( $mode, 'default' )
      {
      next unless $editor_key{$ed_mode}{$keystroke};
      $editor_key{$ed_mode}{$keystroke}->($args,$keystroke);
      last;
      }
    }
  });

# }}}

# }}}

POE::Session->create
  (
  args          => [ $ARGV[0] ],
  inline_states => { %inline_state },
  );
POE::Kernel->run();
exit 0;
